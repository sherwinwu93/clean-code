### 第7章 错误处理
错误处理很重要, 但如果它搞乱了代码逻辑, 就是错误的做法.
#### 7.1 使用异常而非返回错误码
以前许多语言不支持异常,要么设置一个错误标识,要么返回给调用者检查的错误码.
```java
public class DeviceController {
    
    public void sendShutDown() {
        // Check the state of the device
        if (hanle != DeviceHandle.INVALID) {
            // Save the device status to the record field
            retrieveDeviceRecord(handle);
            // If not suspended, shut down
            if (record.getStatus() != DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                closeDevice(handle);
            } else {
                logger.log("Device suspended. Unable to shut down");
            }
        } else {
            logger.log("Invalid handle for: " + DEV1.toString());
        }
    }
}
```
采用异常处理
```java
public class DeviceController {
    
    public void sendShutDown() {
        try {
            tryToShutDown();
        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }
    
    private void tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);
        
        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }
    
    private DeviceHandle getHandle(DeviceID id) {
        throw new DeviceShutDownError("Invalid handle for: " + id.toString());
    }
}
```
#### 7.2 先写Try-Catch-Finally语句
异常的妙处之一是, 它们在程序种定义了一个范围. 执行try-catch-finally语句中try部分的代码时,你是在表明可随时取消执行,并在catch语
句中接续.  
所以, 在编写可能抛出异常的代码时, 最好先写出try-catch-finally语句.这能帮你定义代码的用户应该期待什么,无论try代码块中执行的代码
出什么错都一样.  
举个例子:  
```java
public class Main {
    
    @Test(expected = StorageException.class)
    public void retrieveSectionShouldThrowOnInvalidFileName() {
        sectionStore.retrieveSection("invalid-file");
    }
    
    // 测试失败, 并未抛出异常
    public List<RecordedGrip> retrieveSection(String sectionName) {
        // dummy return util we have a real implementation
        return new ArrayList<RecordedGrip>();
    }
    
    // 重构1: 测试成功, 成功抛出异常
    public List<RecordedGrip> retrieveSection(String sectionName) {
        try {
            FileInputStream stream = new FileInputStream(sectionName);
        } catch (Exception e) {
            throw new StorageException("retrieval error", e);
        }
        return new ArrayList<RecordedGrip>();
    }
    
    // 重构2: 缩小异常类型的范围, 使之符合FileInputStream构造器真正抛出的异常, 即FileNotFoundException:
    public List<RecordedGrip> retrieveSection(String sectionName) {
        try {
            FileInputStream stream = new FileInputStream(sectionName);
            stream.close();
        } catch (FileNotFoundException e) {
            throw new StroageException("retrieval error", e);
        }
        return new ArrayList<RecordedGrip>();
    }
}
```

#### 7.3 使用不可控异常
Java引入可控异常.每个方法的签名都列出它可能传递给调用者的异常.而且,这些异常就是方法类型的一部分.  
代价是什么?可控异常的代价就是违反开闭原则.如果你在方法中抛出可控异常,而catch语句在三个层级之上,你就得在catch语句和抛出异常处
之间的每个方法签名中声明该异常.
#### 7.4 给出异常发生的环境说明
log.error("className.methodName...param->{}")
#### 7.5 依调用者需要定义异常类
对错误分类有很多方式.可以依其来源分类:是来自组件还是其他地方?或依其类型分类:是设备错误、网络错误还是编程错误?不过,当我们在应用
程序中定义异常类时,最重要的考虑应该是它们如何被捕获.  
```java
public class Main {
    public static void main(String[] args){
      ACMEPort port = new ACMEPort(12);
      try {
          port.open();
      } catch (DeviceResponseException e) {
          reportPortError(e);
          logger.log("Device response exception", e);
      } catch (ATM1212UnlockedException e) {
          reportPortError(e);
          logger.log("Unlock exception", e);
      } catch (GMXError e) {
          reportPortError(e);
          logger.log("Device response exception");
      } finally{
          
      }
    }
    // 在上述代码中,既然知道我们所做的事不外如此,就可以通过打包调用API、确保它返回通用异常类型,从而简化代码.
    public static void main(String[] args){
      LocalPort port = new LocalPort(12);
      try {
          port.open();
      } catch (PortDeviceFailure e) {
          reportError(e);
          logger.log(e.getMessage(), e);
      } finally {
          
      }
    }
}
// LocalPort类就是个简单的打包类, 捕获并翻译由ACMEPort类抛出的异常
public class LocalPort {
    private ACMEPort innerPort;
    
    public LocalPort(int portNumber) {
        innerPort = new ACMEPort(portNumber);
    }
    
    public void open() {
        try {
            innerPort.open();
        } catch (DeviceResponseException e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            throw new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
}
```
将第三方API打包是个良好的实践手段.当你打包一个第三方API,就降低了对它的依赖:为来你可以不太痛苦地改用其他代码库.

#### 7.6 定义常规流程
```java
public class Main {
    public static void main(String[] args){
        try{
            MealExpenses expenses = expenseReporyDAO.getMeals(employee.getID());
            m_total += expenses.getTotal();
        } catch (MealExpenseNotFound e) {
            m_total += getMealPerDiem();
        }
    }
}
```
特例模式(SPECIAL CASE PATTERN).创建一个类或者配置一个对象,用来处理特例.异常行为被封装到特例对象中了.  

#### 7.7 别返回null值
```java
public class Test {
    public void registerItem(Item item) {
        if (item != null) {
            ItemRegistry registry = peristentStore.getItemRegistry();
            if (registry != null) {
                Item existing = registry.getItem(item.getID());
                if (existing.getBillingPeriod().hasRetailOwner()) {
                    existing.register(item);
                }
            }
        }
    }
}
```
如果你在调用某个第三方API中可能返回null值得方法,可以考虑用新方法打包这个方法, 在新方法中抛出异常或返回特例对象.  

如果 List<Employee> employees = getEmployees(); 有可能返回空指针异常.  
那么可以处理它 在getEmployees() 方法的实现中增加getEmployees()方法.

#### 7.8 别传递null值
在方法中返回null值是糟糕的做法,但将null值传递给其他方法就更糟糕了.除非API要求你向它传递null值,否则就要尽可能避免传递null值.

```java
public class MetricsCalculator {
    public double xProjection(Point p1, Point p2) {
        return (p2.x - p1.x) * 1.5;
    }
    public static void main(String[] args){
      calculator.xProjection(null, new Point(12, 13));
    }
}
```
大多数编程语言中,没有良好的方法能对付由调用者意外传入的null值.事已如此,恰当的做法就是禁止传入null值.你在编码的时候,就会时时记
住参数列表中的null值出问题了,从而大量避免这种无心之失.

#### 7.9 小结
整洁代码是可读的,但也要强固.可读与强固并不冲突.如果将错误处理隔离看待,独立于主要逻辑之外,就能写出强固而整洁的代码.做到这一步,
我们就能单独处理它,也极大地提升了代码的可维护性.







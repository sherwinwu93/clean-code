### 第7章 错误处理
错误处理很重要, 但如果它搞乱了代码逻辑, 就是错误的做法.
#### 7.1 使用异常而非返回错误码
以前许多语言不支持异常,要么设置一个错误标识,要么返回给调用者检查的错误码.
```java
public class DeviceController {
    
    public void sendShutDown() {
        // Check the state of the device
        if (hanle != DeviceHandle.INVALID) {
            // Save the device status to the record field
            retrieveDeviceRecord(handle);
            // If not suspended, shut down
            if (record.getStatus() != DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                closeDevice(handle);
            } else {
                logger.log("Device suspended. Unable to shut down");
            }
        } else {
            logger.log("Invalid handle for: " + DEV1.toString());
        }
    }
}
```
采用异常处理
```java
public class DeviceController {
    
    public void sendShutDown() {
        try {
            tryToShutDown();
        } catch (DeviceShutDownError e) {
            logger.log(e);
        }
    }
    
    private void tryToShutDown() throws DeviceShutDownError {
        DeviceHandle handle = getHandle(DEV1);
        DeviceRecord record = retrieveDeviceRecord(handle);
        
        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }
    
    private DeviceHandle getHandle(DeviceID id) {
        throw new DeviceShutDownError("Invalid handle for: " + id.toString());
    }
}
```
#### 7.2 先写Try-Catch-Finally语句
异常的妙处之一是, 它们在程序种定义了一个范围. 执行try-catch-finally语句中try部分的代码时,你是在表明可随时取消执行,并在catch语
句中接续.  
所以, 在编写可能抛出异常的代码时, 最好先写出try-catch-finally语句.这能帮你定义代码的用户应该期待什么,无论try代码块中执行的代码
出什么错都一样.  
举个例子:  
```java
public class Main {
    
    @Test(expected = StorageException.class)
    public void retrieveSectionShouldThrowOnInvalidFileName() {
        sectionStore.retrieveSection("invalid-file");
    }
    
    // 测试失败, 并未抛出异常
    public List<RecordedGrip> retrieveSection(String sectionName) {
        // dummy return util we have a real implementation
        return new ArrayList<RecordedGrip>();
    }
    
    // 重构1: 测试成功, 成功抛出异常
    public List<RecordedGrip> retrieveSection(String sectionName) {
        try {
            FileInputStream stream = new FileInputStream(sectionName);
        } catch (Exception e) {
            throw new StorageException("retrieval error", e);
        }
        return new ArrayList<RecordedGrip>();
    }
    
    // 重构2: 缩小异常类型的范围, 使之符合FileInputStream构造器真正抛出的异常, 即FileNotFoundException:
    public List<RecordedGrip> retrieveSection(String sectionName) {
        try {
            FileInputStream stream = new FileInputStream(sectionName);
            stream.close();
        } catch (FileNotFoundException e) {
            throw new StroageException("retrieval error", e);
        }
        return new ArrayList<RecordedGrip>();
    }
}
```

#### 7.3 使用不可控异常
Java引入可控异常.每个方法的签名都列出它可能传递给调用者的异常.而且,这些异常就是方法类型的一部分.  
代价是什么?可控异常的代价就是违反开闭原则.如果你在方法中抛出可控异常,而catch语句在三个层级之上,你就得在catch语句和抛出异常处
之间的每个方法签名中声明该异常.
#### 7.4 给出异常发生的环境说明
log.error("className.methodName...param->{}")
#### 7.5 依调用者需要定义异常类
对错误分类有很多方式.可以依其来源分类:是来自组件还是其他地方?或依其类型分类:是设备错误、网络错误还是编程错误?不过,当我们在应用
程序中定义异常类时,最重要的考虑应该是它们如何被捕获.  
```java
public class Main {
    public static void main(String[] args){
      ACMEPort port = new ACMEPort(12);
      try {
          port.open();
      } catch (DeviceResponseException e) {
          reportPortError(e);
          logger.log("Device response exception", e);
      } catch (ATM1212UnlockedException e) {
          reportPortError(e);
          logger.log("Unlock exception", e);
      } catch (GMXError e) {
          reportPortError(e);
          logger.log("Device response exception");
      } finally{
          
      }
    }
    // 在上述代码中,既然知道我们所做的事不外如此,就可以通过打包调用API、确保它返回通用异常类型,从而简化代码.
    public static void main(String[] args){
      LocalPort port = new LocalPort(12);
      try {
          port.open();
      } catch (PortDeviceFailure e) {
          reportError(e);
          logger.log(e.getMessage(), e);
      } finally {
          
      }
    }
}
// LocalPort类就是个简单的打包类, 捕获并翻译由ACMEPort类抛出的异常
public class LocalPort {
    private ACMEPort innerPort;
    
    public LocalPort(int portNumber) {
        innerPort = new ACMEPort(portNumber);
    }
    
    public void open() {
        try {
            innerPort.open();
        } catch (DeviceResponseException e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            throw new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
}
```








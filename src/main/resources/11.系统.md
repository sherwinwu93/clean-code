### 11.系统
"复杂要人名.它消磨开发者的生命,让产品难以规划、构建和测试."--Ray Ozzie,微软公司首席技术官.

#### 11.1 如何建造一个城市
城市能运转,因为它演化出恰当的抽象等级和模块,好让个人和他们所管理的"组件",即便不了解全局时也能有效地运转.
如何在较高的抽象层级--系统层级--上保持整洁.

#### 11.2 将系统的构造与使用分开
酒店在构造时,起重机和升降机.酒店在建成后,这些就消失不见,变得整洁.  
软件系统也应将启动过程和启动过程之后的运行时逻辑分离开,在启动过程中构建应用对象,也会存在互相缠结的依赖关系.  
```java
public class Main {
    /**
    * 没有做分离处理.
    * 延迟初始化/赋值
    * @return 
    */
    public Service getService() {
        if (service == null)
            service = new MyServiceImpl();//Good enough default for most cases?
        return service;
    }
}
```
我们不知道MyServiceImpl在所有情形中是否都是正确的对象.这是一种全局设置策略,如果在应用程序中四散分布,缺乏模块组
织性,通常也会有许多重复代码.  
所以,我们勤于打造有着良好格式并且强固的系统,就不该用这类就手小技巧破坏模块组织性.

##### 11.2.1 分解main
将全部构建过程搬迁到main或者main的模块中,.应用程序对main或者构造过程一无所知.它只是简单地指望一切已完备.

图11-1.将构造分解到main中.vsd

##### 11.2.2 工厂
应用程序也需要创建对象.

##### 11.2.3 依赖注入
依赖注入:强大的机制实现分离构造与使用.  
控制反转:在依赖管理中的一种应用手段.控制反转将第二权责从对象中拿出来,转移到另一个专注于此的对象中,从而遵循了SRP.
对象不负责实体化对自身的依赖,反之它将这份权责移交给其他"有权力"的机制,从而实现控制的反转.  
初始设置是一种全局问题,这种授权机制通常是main例程,要么是有特定目的的容器.




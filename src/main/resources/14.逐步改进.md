# 第14章 逐步改进--对一个命令行参数解析程序的案例研究
案例: 开始不错->随规模变大出问题->重构  
```java
public class Args {
    public static void main(String[] args){
      try {
          // 格式化字符串
          Args arg = new Args("1,p#,d*", args);
          boolean logging = arg.getBoolean('l');
          int port = arg.getInt('p');
          String directory = arg.getString('d');
          executeApplication(logging, port, directory);
      } catch (ArgsException e) {
          System.out.printf("Argumenterror:%s\n", e.errorMessage());
      }
    }
}
```

## 14.1 Args的实现
目录:c14.author  
这段代码符合开闭原则,非常整洁.  
要怎么样做到呢?先写肮脏代码,然后再清理它.  
工作中,代码不是能工作就行了.如果代码能工作就行了,就会一直停留在能工作的状态.  

## 14.2 Args:草稿
草稿版本:在作者注意变量名和函数名以及结构的情况下,仍然不够简洁.所以只能称呼为草稿版本,而且还要庆幸它能够工作.  

事情是怎么失控的?代码是如何生长得混乱的?  
开始只需要支持Boolean参数,代码还算可以.后面添加了对String的支持,代码开始生长的混乱了.  

### 14.2.1 所以我暂停了
暂停添加特性,开始重构.  
分析共同点: 
1. 每种参数类型解析其范式,用hashMap
2. 每种参数类型需要在命令行字符串中解析,再转换成真实类型.
3. 最后,每个参数都需要getXXX方法,按照真实类型返回参数值.

结论: ArgumentMarshaler

### 14.2.2 渐进
测试驱动开发,程序的任何改进都得在保证系统正常的前提.  
每次作出大量小规模修改,每次修改都向ArgumentMarshaler概念推动.




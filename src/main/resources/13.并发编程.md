### 第13章 并发编程
对象是过程的抽象.线程是调度的抽象.

表面上编写多线程代码容易,实际上系统一旦遭受压力,代码就会扛不住.

#### 13.1 为什么要并发
并发是解耦策略,把做什么和什么时候做分解开.和单线程不同,单线程目的和时机紧密耦合.  
解耦目的与实际能明显改进应用程序的吞吐量和结构.结构上,系统像多台协同工作的计算机,给出许多切分关注面的有力手段.  
Web应用的Servlet标准模式.运行在Web容器和EJB容器下,Web或EJB处理并发问题.servlet与其他servlet是分离的.  
但是Web容器并不是那么完美.  
结构也不是并发的唯一理由.也有可能是性能方面有需求.例如:同时请求多个站点的资源;并发处理多个用户请求,提高系统响应时间.  

###### 迷思与误解
1. 并发总能改进性能: 并发只在多个线程或处理器分享大量等待时间的时候管用.
2. 编写并发程序无需修改设计: 目的与时机的解耦往往使得系统结构产生巨大影响.
3. 采用Web容器,理解并发问题并不重要: 最好了解容器在做什么,并发更新、死锁等问题.

###### 中肯说法
1. 并发会在性能和编写额外代码上增加一些开销;
2. 正确的并发是复杂的,即便对于简单问题也是如此;
3. 并发缺陷并非总能重现,常被当偶发事件而忽略,没有当成bug看待;
4. 并发常常需要对设计策略的根本性修改.

##### 13.2 挑战
并发例子:  
```java
public class X {
    private int lastIdUsed;
    public int getNextId() {
        return ++lastIdUsed;
    }
    public static void main(String[] args){
        X x = new X();
        Runnable runnable = new Runnable() {
            public void run() {
                System.out.print(Thread.currentThread());
                System.out.print(x.getNextId());
            }
        };
        Thread t1 = new Thread(runnable);
        Thread t2 = new Thread(runnable);
        t1.start();
        t2.start();
        System.out.print(x.lastIdUsed);
        //~线程1 43, 线程2 44, lastIdUsed 44;
        //~线程1 44, 线程2 43, lastIdUsed 44;
        //~线程1 43, 线程2 43, lastIdUsed 43;
    }
}
```
结果令人吃惊,因为线程在执行那行java代码有许多可能路径可行,有些路径会产生错误的结果.有多少路径,需要理解Just-In-Time,Java内存模
型的原子性.  
简单来说.刚才的两个线程有12870中不同的路径.如果lastIdUsed从int改为long,则有2704156种.

#### 13.3 并发防御原则
##### 13.3.1 单一权责原则
SRP认为,方法/类/组件应当只有一个修改的理由.并发设计自身的复杂到成为修改的理由,所以也应该分解出来.需要考虑如下问题:
1. 并发相关代码有自己的开发、修改和调优生命周期;
2. 开发相关代码的难点和非并发相关代码不同,往往更为困难;
3. 写的不好的并发代码可能的出错方式太多了  
建议:分离并发相关代码与其他代码.

##### 13.3.2 推论:限制数据作用域
多线程修改共享对象的同一字段,可能互相干扰,导致未预期的行为.  
更新共享数据地方越多,就越可能:
1. 忘记保护临界区;
2. 得多花功夫做保护;
3. debug难.  
建议:使用synchronized关键字保护临界区,严格保护可能被共享的数据.

##### 13.3.3 推论: 使用数据副本
使用数据副本,避免锁定的价值可能补偿得上额外的创建成本和垃圾收集开销.

##### 13.3.4 推论:线程应可能地独立
尝试将数据分解到可被独立线程操作的独立子集.

#### 13.4 了解Java库
Java5编写线程代码,注意以下几点:
1. 使用类库提供的线程安全群集;
2. 使用executor框架执行无关任务;
3. 尽可能使用非锁定解决方案;
4. 有几个类并不是线程安全的.

###### 线程安全群集
<table>
<tr>
    <td>ReentrantLock</td>
    <td>可在一个方法种获取、在另一个方法中释放的锁</td>
</tr>
<tr>
    <td>Semaphore</td>
    <td>经典的"信号"的一种实现,有计数器的锁</td>
</tr>
<tr>
    <td>CountDownLatch</td>
    <td>在释放所有等待的线程之前,等待指定数量事件发生的锁.这样,所有的线程都平等地几乎同时启动.</td>
</tr>
</table>
建议:检读可用的类.对于Java,掌握java.util.concurrent、java.util.concurrent.atomic和java.util.concurrent.locks.

#### 13.5 了解执行模型
一些执行模型的基础定义
<table>
    <tr>
        <td>限定资源</td>
        <td>并发环境中有者固定尺寸或数量的资源.例如数据库连接和固定尺寸读/写缓存</td>
    </tr>
    <tr>
        <td>互斥</td>
        <td>每一时刻仅有一个线程能访问共享数据或共享资源</td>
    </tr>
    <tr>
        <td>线程饥饿</td>
        <td>一个或一组线程在很长时间内或永久被禁止.例如,总是让执行得快的线程先运行,例如执行得快的线程没完没了,则执行时间长的
        线程就会"挨饿"</td>
    </tr>
    <tr>
        <td>死锁</td>
        <td>两个或多个线程互相等待执行结束.每个线程都拥有其他线程需要的资源,得不到其他线程拥有的资源,就无法终止</td>
    </tr>
    <tr>
        <td>活锁</td>
        <td>执行次序一致的线程,每个都想要起步,但发现其他线程已经"在路上".由于竞步的原因,线程会持续尝试起步,但在很长时间内
        却无法如愿,甚至永远无法启动</td>
    </tr>
</table>

##### 13.5.1 生产者-消费者模型
生产者线程创建工作,缓存到队列.消费者线程从队列中获取并完成工作.这个队列是限定资源.

##### 13.5.2 读者-作者模型
主要为读者线程提供资源,偶尔为作者线程更新提供资源,就会产生吞吐量的问题.导致线程饥饿和过时信息的累积.作者线程会锁定正在更新的
信息,导致吞吐量的问题.  
所以要平衡好读者线程和作者线程的需求,实现正确操作,提供合理吞吐量,避免线程饥饿.  

##### 13.5.3 宴席哲学家
线程既是哲学家,资源是叉子.这就是企业级应用中进程竞争资源的情形,死锁,活锁,吞吐量和效率降低等问题.  
建议:学习这些基础算法,理解其解决方案.

#### 13.6 警惕同步方法之间的依赖
一个共享类里面有多个同步方法,系统可能出问题了.  
建议:避免使用一个共享对象的多个方法.
1. 基于客户端的锁定--客户端代码调用时,锁的范围从第一个方法到最后一个方法;
2. 基于服务器的锁定--服务器段创建锁定服务端的方法,调用所有方法,然后解锁.让客户端代码调用新方法;
3. 适配服务器--创建执行锁定的中间层.基于服务器锁定,但不修改原始服务端代码.

#### 13.7 保持同步区域微小
如果资源是钱的话,那么锁是昂贵的.锁越大越昂贵. 
建议:尽可能减少同步区域.

#### 13.8 很难编写正确的关闭代码
建议:今早考虑关闭问题,尽早令其工作正常.避免死锁的问题.

#### 13.9 测试线程代码
单线程能通过测试确保正确性,但是多线程情况下,事情变得复杂了.  
建议: 编写有潜力暴露问题的测试,不同编程配置、系统配置和负载条件下频繁运行.前面测试失败,不要因为后面测试成功就忽略失败.
1. 将伪失败看作可能的线程问题;
2. 先使非线程代码可工作;
3. 编写可插拔的线程代码;
4. 运行多于处理器数量的线程;
5. 在不同平台上运行;
6. 调整代码并强迫错误发生.

##### 13.9.1 将伪失败看作可能的线程问题


